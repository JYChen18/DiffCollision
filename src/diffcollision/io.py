from dataclasses import dataclass
import numpy as np
import os
import trimesh
import torch

from diffcollision.cpp._coal_openmp import get_convex_from_file, get_convex_from_data
from diffcollision.utils import DCTensorSpec


@dataclass
class DCMesh:
    """
    A mesh representation for Differentiable Collision detection.

    Attributes
    ----------
    coarse_mesh : trimesh.Trimesh
        The coarse, watertight mesh used for visualization and sampling (no internal faces).
    fine_mesh : trimesh.Trimesh
        The fine-grained trimesh object, merged from convex pieces (has internal faces).
    convex_pieces : list of coal::CollisionGeometry
        List of convex collision geometries (from C++ 'Coal' library), used for the narrow-phase (GJK/EPA) detection.
    bounding_spheres : torch.Tensor, shape (N, 4)
        Bounding spheres (center_xyz, radius) for each convex piece, used for broad-phase culling.
    n_cvx : int
        Number of convex pieces in the mesh. Automatically computed during initialization.
    """

    coarse_mesh: trimesh.Trimesh
    fine_mesh: trimesh.Trimesh
    convex_pieces: list
    bounding_spheres: torch.Tensor
    n_cvx: int = 0

    @staticmethod
    def from_data(
        vertices: np.ndarray, faces: np.ndarray, ts: DCTensorSpec = DCTensorSpec()
    ):
        """
        Create a DCMesh directly from vertex and face arrays, supporting only convex objects.

        Parameters
        ----------
        vertices : np.ndarray, shape (N, 3)
            Vertex positions.
        faces : np.ndarray, shape (M, 3)
            Triangle face indices.
        ts : DCTensorSpec, optional
            Tensor specification for device and dtype. Default: dtype=float and device=cpu.
        """
        tm = trimesh.Trimesh(vertices, faces).convex_hull

        # For broad phase filter
        center, radius = trimesh.nsphere.minimum_nsphere(tm)
        sphere_lst = np.concatenate([center, [radius]])[None]

        # For narrow phase convex-convex GJK/EPA
        cvx_lst = [get_convex_from_data(vertices)]
        return DCMesh(tm, tm, cvx_lst, ts.to(sphere_lst))

    @staticmethod
    def from_file(
        obj_path: str,
        scale: float = 1.0,
        convex_hull: bool = True,
        ts: DCTensorSpec = DCTensorSpec(),
    ):
        """
        Load a DCMesh from file(s), supporting both convex and concave objects.

        Parameters
        ----------
        obj_path : str
            Path to the object file.
            - For **convex meshes**, this can be a single `.obj` file or
            a directory containing the processed mesh data generated by
            [MeshProcess](https://github.com/JYChen18/MeshProcess).
            - For **concave meshes**, only MeshProcess-processed directories are supported.

        scale : float, optional
            Scaling factor applied to all mesh vertices. Default: 1.0.

        convex_hull : bool, optional
            If True, load the object as a convex hull. If False, load as a concave mesh. Default: True.

        ts : DCTensorSpec, optional
            Tensor specification for device and dtype. Default: dtype=float and device=cpu.
        """
        if convex_hull:
            return _load_convex_from_file(obj_path, scale, ts)
        else:
            assert os.path.isfile(
                os.path.join(obj_path, "mesh/simplified.obj")
            ), "currently only support meshes processed by https://github.com/JYChen18/MeshProcess"
            return _load_concave_from_file(obj_path, scale, ts)

    def __post_init__(self):
        self.n_cvx = len(self.convex_pieces)


def _load_convex_from_file(obj_path: str, scale: float, ts: DCTensorSpec) -> DCMesh:
    if not os.path.isfile(obj_path):
        obj_path = os.path.join(obj_path, "mesh/simplified.obj")

    tm = trimesh.load(obj_path, force="mesh").convex_hull
    tm.vertices *= scale

    # For broad phase filter
    center, radius = trimesh.nsphere.minimum_nsphere(tm)
    sphere_lst = np.concatenate([center, [radius]])[None]

    # For narrow phase convex-convex GJK/EPA
    cvx_lst = [get_convex_from_file(obj_path, np.array([scale] * 3))]
    return DCMesh(tm, tm, cvx_lst, ts.to(sphere_lst))


def _load_concave_from_file(obj_path: str, scale: float, ts: DCTensorSpec) -> DCMesh:
    tm_path = os.path.join(obj_path, "mesh/simplified.obj")
    convex_path = os.path.join(obj_path, "urdf/meshes")
    file_lst = [os.path.join(convex_path, i) for i in sorted(os.listdir(convex_path))]

    cm = trimesh.load(tm_path, force="mesh")
    cm.vertices *= scale

    sphere_lst = []
    cvx_lst = []
    fm_lst = []
    for f in file_lst:
        # For broad phase filter
        m = trimesh.load(f, force="mesh")
        m.vertices *= scale
        center, radius = trimesh.nsphere.minimum_nsphere(m)
        sphere_lst.append(np.concatenate([center, [radius]]))
        # For narrow phase convex-convex GJK/EPA
        cvx_lst.append(get_convex_from_file(f, np.array([scale] * 3)))
        fm_lst.append(m)
    sphere_lst = np.stack(sphere_lst)
    fm = trimesh.util.concatenate(fm_lst)
    return DCMesh(cm, fm, cvx_lst, ts.to(sphere_lst))
